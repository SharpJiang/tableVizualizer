/*
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.*;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.*;
import javax.swing.text.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import model.Tables;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

public class MainJFrame extends javax.swing.JFrame {

    private static int numberOfTables = 0;

    private static List<Tables> tables;
    private static List<JTable> Jtables;

    private static int selectedTable = -1;

    private static boolean[] tableChecked;

    public static Integer allErrors = 0;

    private File fileToSave = null;

    class TableActionListener implements ActionListener {

        public void actionPerformed(ActionEvent e) {
            jPanel.removeAll();
            String tableInfo = e.getActionCommand();
            selectedTable = Character.getNumericValue(tableInfo.charAt(tableInfo.length() - 1)) - 1;
            fillTable(false, Character.getNumericValue(tableInfo.charAt(tableInfo.length() - 1)) - 1);
        }
    }

    class AllTablesActionListener implements ActionListener {

        public void actionPerformed(ActionEvent e) {
            jPanel.removeAll();
            selectedTable = -1;
            fillTable(true, -1);
        }
    }

*
     * Creates new form MainJFrame


    public MainJFrame() {

        Image image = Toolkit.getDefaultToolkit().createImage("images\\icons\\logo.png");
        setIconImage(image);
        ActionListener exitAL = new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.exit(0);
            }
        };
        if (SystemTray.isSupported()) {
            PopupMenu pm = new PopupMenu();
            MenuItem miExit = new MenuItem("Выход");
            miExit.addActionListener(exitAL);
            MenuItem miRestore = new MenuItem("Восстановить");
            miRestore.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    restoreWindow();
                }
            });
            pm.add(miRestore);
            pm.addSeparator();
            pm.add(miExit);
            SystemTray st = SystemTray.getSystemTray();
            TrayIcon ti = new TrayIcon(image, "Двойной щелчок для восстановления окна", pm);
            ti.addMouseListener(new TrayMouseListener());
            try {
                st.add(ti);
                addWindowListener(new WindowMinimizeListener());
            } catch (AWTException ex) {
                ex.printStackTrace();
            }
        }
        
        initComponents();
        remove(jScrollPane);
        errorLabel.setVisible(false);
        errorNumberLabel.setVisible(false);
    }

*
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.


    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane = new javax.swing.JScrollPane();
        jPanel = new javax.swing.JPanel();
        errorLabel = new javax.swing.JLabel();
        errorNumberLabel = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        saveMenuItem = new javax.swing.JMenuItem();
        saveAsMenuItem = new javax.swing.JMenuItem();
        exportMenu = new javax.swing.JMenu();
        jMenuItem4 = new javax.swing.JMenuItem();
        closejMenuItem = new javax.swing.JMenuItem();
        jMenuItem6 = new javax.swing.JMenuItem();
        jMenuTables = new javax.swing.JMenu();
        jMenuItem7 = new javax.swing.JMenuItem();
        jMenuAbout = new javax.swing.JMenu();
        jMenuItem8 = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jScrollPane.setBackground(new java.awt.Color(204, 204, 204));
        jScrollPane.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Будтьте внимательны в процессе редактирования!", javax.swing.border.TitledBorder.LEFT, javax.swing.border.TitledBorder.TOP, new java.awt.Font("SansSerif", 3, 24), new java.awt.Color(204, 0, 51))); // NOI18N

        javax.swing.GroupLayout jPanelLayout = new javax.swing.GroupLayout(jPanel);
        jPanel.setLayout(jPanelLayout);
        jPanelLayout.setHorizontalGroup(
            jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1286, Short.MAX_VALUE)
        );
        jPanelLayout.setVerticalGroup(
            jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 439, Short.MAX_VALUE)
        );

        jScrollPane.setViewportView(jPanel);

        errorLabel.setFont(new java.awt.Font("Times New Roman", 3, 12)); // NOI18N
        errorLabel.setForeground(new java.awt.Color(0, 51, 255));
        errorLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);

        errorNumberLabel.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        errorNumberLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        errorNumberLabel.setText("-");

        jLabel1.setBackground(java.awt.Color.red);
        jLabel1.setForeground(java.awt.Color.red);
        jLabel1.setText("jLabel1");
        jLabel1.setOpaque(true);

        jLabel2.setFont(new java.awt.Font("Times New Roman", 2, 12)); // NOI18N
        jLabel2.setForeground(new java.awt.Color(0, 153, 153));
        jLabel2.setText("- зона повішенного внимания;");

        jLabel3.setBackground(java.awt.Color.green);
        jLabel3.setForeground(java.awt.Color.green);
        jLabel3.setText("jLabel3");
        jLabel3.setOpaque(true);

        jLabel4.setFont(new java.awt.Font("Times New Roman", 2, 12)); // NOI18N
        jLabel4.setForeground(new java.awt.Color(0, 153, 153));
        jLabel4.setText("- корректный участок док-та;");

        jLabel5.setFont(new java.awt.Font("Times New Roman", 3, 12)); // NOI18N
        jLabel5.setForeground(new java.awt.Color(0, 51, 255));
        jLabel5.setText("Обозначения:");

        jLabel6.setBackground(new java.awt.Color(153, 102, 0));
        jLabel6.setForeground(new java.awt.Color(153, 102, 0));
        jLabel6.setText("jLabel6");
        jLabel6.setOpaque(true);

        jLabel7.setFont(new java.awt.Font("Times New Roman", 2, 12)); // NOI18N
        jLabel7.setForeground(new java.awt.Color(0, 153, 153));
        jLabel7.setText("- внесённые изменения");

        jMenu1.setText("Файл");
        jMenu1.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N

        jMenuItem1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem1.setIcon(new javax.swing.ImageIcon("images\\icons\\open.png"));
        jMenuItem1.setText("Открыть...");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem1);

        saveMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        saveMenuItem.setIcon(new javax.swing.ImageIcon("images\\icons\\save.png"));
        saveMenuItem.setText("Сохранить");
        saveMenuItem.setEnabled(false);
        saveMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveMenuItemActionPerformed(evt);
            }
        });
        jMenu1.add(saveMenuItem);

        saveAsMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        saveAsMenuItem.setIcon(new javax.swing.ImageIcon("images\\icons\\save_all.png"));
        saveAsMenuItem.setText("Сохранить как...");
        saveAsMenuItem.setEnabled(false);
        saveAsMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveAsMenuItemActionPerformed(evt);
            }
        });
        jMenu1.add(saveAsMenuItem);

        exportMenu.setIcon(new javax.swing.ImageIcon("images\\icons\\export.png"));
        exportMenu.setText("Экспортировать");
        exportMenu.setEnabled(false);

        jMenuItem4.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_1, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem4.setForeground(new java.awt.Color(255, 0, 0));
        jMenuItem4.setText("csv");
        jMenuItem4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem4ActionPerformed(evt);
            }
        });
        exportMenu.add(jMenuItem4);

        jMenu1.add(exportMenu);

        closejMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_W, java.awt.event.InputEvent.CTRL_MASK));
        closejMenuItem.setIcon(new javax.swing.ImageIcon("images\\icons\\close.png"));
        closejMenuItem.setText("Закрыть");
        closejMenuItem.setEnabled(false);
        closejMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closejMenuItemActionPerformed(evt);
            }
        });
        jMenu1.add(closejMenuItem);

        jMenuItem6.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F4, java.awt.event.InputEvent.ALT_MASK));
        jMenuItem6.setText("Выход");
        jMenuItem6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem6ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem6);

        jMenuBar1.add(jMenu1);

        jMenuTables.setText("Таблицы");
        jMenuTables.setEnabled(false);
        jMenuTables.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N

        jMenuItem7.setIcon(new javax.swing.ImageIcon("images\\icons\\empty.png"));
        jMenuItem7.setText("Нет данных");
        jMenuTables.add(jMenuItem7);

        jMenuBar1.add(jMenuTables);

        jMenuAbout.setText("О программе");
        jMenuAbout.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N

        jMenuItem8.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F1, 0));
        jMenuItem8.setIcon(new javax.swing.ImageIcon("images\\icons\\reference.png"));
        jMenuItem8.setText("Справка");
        jMenuItem8.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem8ActionPerformed(evt);
            }
        });
        jMenuAbout.add(jMenuItem8);

        jMenuBar1.add(jMenuAbout);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(errorLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(errorNumberLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(142, 142, 142)
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 19, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 5, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 11, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel7)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {jLabel1, jLabel3, jLabel6});

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {jLabel2, jLabel4, jLabel7});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel1)
                        .addComponent(jLabel2)
                        .addComponent(jLabel3)
                        .addComponent(jLabel4)
                        .addComponent(jLabel6)
                        .addComponent(jLabel7))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(errorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(errorNumberLabel)
                        .addComponent(jLabel5)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 480, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {errorLabel, errorNumberLabel, jLabel2, jLabel4, jLabel5, jLabel7});

        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {jLabel1, jLabel3, jLabel6});

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void saveAsMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveAsMenuItemActionPerformed

        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Сохранить как");

        int userSelection = fileChooser.showSaveDialog(this);

        if (userSelection == JFileChooser.APPROVE_OPTION) {

            fileToSave = fileChooser.getSelectedFile();

            if (!getFileExtension(fileToSave).equals("xml")) {
                fileToSave = new File(fileToSave.toString() + ".xml");
            }

            saveUsersXML();

            saveMenuItem.setEnabled(true);

        }
    }//GEN-LAST:event_saveAsMenuItemActionPerformed

    public void saveUsersXML() {
        try {

            if (selectedTable == -1) {

                saveFileExists();

            } else {

                if (fileToSave.exists()) {

                    Tables tempTable = tables.get(selectedTable);

                    DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
                    DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
                    Document doc = docBuilder.parse(fileToSave);

                    // Get the root element
                    Node tables = doc.getFirstChild();

                    NodeList list = tables.getChildNodes();

                    int ind;

                    for (ind = 0; ind < list.getLength(); ind++) {
                        Node node = list.item(ind);
                        if ("table".equals(node.getNodeName())) {
                            NamedNodeMap attr = node.getAttributes();
                            Node nodeAttr = attr.getNamedItem("id");

                            if (nodeAttr.toString().equals("id=\"" + (selectedTable + 1) + "\"")) {
                                removeChilds(node);

                                addXMLData(doc, tempTable, (Element) node);

                                break;
                            }
                        }
                    }

                    TransformerFactory transformerFactory = TransformerFactory.newInstance();
                    Transformer transformer = transformerFactory.newTransformer();
                    DOMSource source = new DOMSource(doc);
                    StreamResult result = new StreamResult(new File(fileToSave.getAbsolutePath()));
                    transformer.transform(source, result);
                } else {
                    saveFileExists();
                }
            }

        } catch (ParserConfigurationException | IOException | TransformerException | SAXException ex) {
            Logger.getLogger(MainJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void saveFileExists() {
        try {
            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = f.newDocumentBuilder();

            Document doc = builder.newDocument();
            Element AllTables = doc.createElement("tables");
            doc.appendChild(AllTables);

            Element parserID = doc.createElement("vizualizer-xml");
            Attr versionAttr = doc.createAttribute("version");
            versionAttr.setValue(version);
            parserID.setAttributeNode(versionAttr);
            AllTables.appendChild(parserID);

            Element tablesNumber = doc.createElement("tables-number");
            tablesNumber.appendChild(doc.createTextNode(Integer.toString(numberOfTables)));
            AllTables.appendChild(tablesNumber);

            if (!fileToSave.exists()) {
                fileToSave.createNewFile();
            }

            Tables tempTable = null;

            for (int t = 0; t < tables.size(); t++) {

                tempTable = tables.get(t);

                Element currTable = doc.createElement("table");
                Attr idAttr = doc.createAttribute("id");

                idAttr.setValue(tempTable.getId());

                currTable.setAttributeNode(idAttr);
                AllTables.appendChild(currTable);

                addXMLData(doc, tempTable, currTable);

            }
            TransformerFactory tFactory = TransformerFactory.newInstance();
            Transformer transformer = tFactory.newTransformer();
            DOMSource source = new DOMSource(doc);
            StreamResult result = new StreamResult(fileToSave);
            transformer.transform(source, result);
        } catch (ParserConfigurationException | IOException | TransformerException ex) {
            Logger.getLogger(MainJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void saveMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveMenuItemActionPerformed

        saveUsersXML();

    }//GEN-LAST:event_saveMenuItemActionPerformed

    public static void removeChilds(Node node) {
        while (node.hasChildNodes()) {
            node.removeChild(node.getFirstChild());
        }
    }

    public static void addXMLData(Document doc, Tables tempTable, Element currTable) {

        Element tableTitle = doc.createElement("table-title");
        tableTitle.appendChild(doc.createTextNode(tempTable.getTitle()));
        currTable.appendChild(tableTitle);

        Element tableDescription = doc.createElement("table-description");
        tableDescription.appendChild(doc.createTextNode(tempTable.getDescription()));
        currTable.appendChild(tableDescription);

        Element tableHeader = doc.createElement("head-row");

        for (int k = 0; k < tempTable.getHeadColumns().size(); k++) {
            Element tableHeaderCell = doc.createElement("cell");
            tableHeaderCell.appendChild(doc.createTextNode(tempTable.getHeadColumns().get(k)));
            tableHeader.appendChild(tableHeaderCell);
        }

        currTable.appendChild(tableHeader);

        for (int m = 0; m < tempTable.getRows().size(); m++) {
            Element tableRow = doc.createElement("row");
            for (int n = 0; n < tempTable.getRows().get(m).size(); n++) {
                Element tableRowCell = doc.createElement("cell");
                tableRowCell.appendChild(doc.createTextNode(tempTable.getRows().get(m).get(n)));
                tableRow.appendChild(tableRowCell);
            }
            currTable.appendChild(tableRow);
        }
    }

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed

        JFileChooser fileopen = new JFileChooser();

        UIManager.put("FileChooser.openDialogTitleText", "Открытие файла");
        UIManager.put("FileChooser.lookInLabelText", "Обзор");
        UIManager.put("FileChooser.openButtonText", "Открыть");
        UIManager.put("FileChooser.cancelButtonText", "Отмена");
        UIManager.put("FileChooser.fileNameLabelText", "Имя файла");
        UIManager.put("FileChooser.filesOfTypeLabelText", "Расширение файла");
        UIManager.put("FileChooser.upFolderToolTipText", "На уровень выше");
        UIManager.put("FileChooser.homeFolderToolTipText", "Рабочий стол");
        UIManager.put("FileChooser.newFolderToolTipText", "Создать новую папку");
        UIManager.put("FileChooser.listViewButtonToolTipText", "Список");
        UIManager.put("FileChooser.newFolderButtonText", "Создать новую папку");
        UIManager.put("FileChooser.detailsViewButtonToolTipText", "Детальнее");
        SwingUtilities.updateComponentTreeUI(fileopen);

        FileNameExtensionFilter xmlfilter = new FileNameExtensionFilter(
                "xml files (*.xml)", "xml");
        fileopen.setFileFilter(xmlfilter);

        int ret = fileopen.showOpenDialog(null);
        if (ret == JFileChooser.APPROVE_OPTION) {
            File file = fileopen.getSelectedFile();
            if (!getFileExtension(file).equals("xml")) {
                JOptionPane.showMessageDialog(null, "Невозможно открыть файл! Пожалуйста, выберите файл\n с расширением \".xml\"", "Ошибка открытия файла.", JOptionPane.ERROR_MESSAGE);
            } else {
                this.setTitle(file.getPath() + " - " + "Визуализатор " + version);
                showTablesItems(getNumberOfTables(file));
                getContentOfAllTables(file);
                add(jScrollPane);
                fillTable(true, -1);
                jMenuTables.setEnabled(true);
            }
            saveAsMenuItem.setEnabled(true);
            exportMenu.setEnabled(true);
            closejMenuItem.setEnabled(true);
        }
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void jMenuItem4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem4ActionPerformed
        //System.out.println("Export to csv clicked");
        if (allErrors != 0) {
            String[] options = new String[2];
            options[0] = "Да";
            options[1] = "Нет";
            int n = JOptionPane.showOptionDialog(null, "Вы действительно хотите экспортировать документ,\nсодержащий ошибки?", "Попытка экспорта документа", 0, JOptionPane.QUESTION_MESSAGE, null, options, null);
            if (n == 0) {
                exportToCSV();
            }
        }

    }//GEN-LAST:event_jMenuItem4ActionPerformed

    private void exportToCSV() {

        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Экспорт в csv");

        int userSelection = fileChooser.showSaveDialog(this);

        if (userSelection == JFileChooser.APPROVE_OPTION) {

            File csvFile = fileChooser.getSelectedFile();

            if (!getFileExtension(csvFile).equals("csv")) {
                csvFile = new File(csvFile.toString() + ".csv");
            }

            try {

                Tables tempTable = null;
                PrintWriter writer = null;

                String path = csvFile.getAbsolutePath();

                StringBuilder sb = null;

                for (int t = 0; t < tables.size(); t++) {

                    sb = new StringBuilder(path);

                    String str = sb.substring(0, sb.indexOf(".csv"));

                    sb = new StringBuilder(str);

                    tempTable = tables.get(t);

                    sb.append("(").append(transliterate(tempTable.getTitle())).append(").csv");

                    writer = new PrintWriter(new File(sb.toString()), "UTF-8");

                    for (int k = 0; k < tempTable.getHeadColumns().size(); k++) {
                        writer.print(tempTable.getHeadColumns().get(k));
                        if (k != tempTable.getHeadColumns().size() - 1) {
                            writer.print(",");
                        } else {
                            writer.print("\n");
                        }
                    }

                    for (int m = 0; m < tempTable.getRows().size(); m++) {
                        for (int n = 0; n < tempTable.getRows().get(m).size(); n++) {
                            writer.print(tempTable.getRows().get(m).get(n));
                            if (n != tempTable.getRows().get(m).size() - 1) {
                                writer.print(",");
                            } else {
                                writer.print("\n");
                            }
                        }
                    }
                    writer.close();
                }

            } catch (IOException e) {
            }

        }
    }

    public static String transliterate(String message) {
        char[] abcCyr = {' ', 'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', 'А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Б', 'Э', 'Ю', 'Я', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
        String[] abcLat = {" ", "a", "b", "v", "g", "d", "e", "e", "zh", "z", "i", "y", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u", "f", "h", "ts", "ch", "sh", "sch", "", "i", "", "e", "ju", "ja", "A", "B", "V", "G", "D", "E", "E", "Zh", "Z", "I", "Y", "K", "L", "M", "N", "O", "P", "R", "S", "T", "U", "F", "H", "Ts", "Ch", "Sh", "Sch", "", "I", "", "E", "Ju", "Ja", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"};
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < message.length(); i++) {
            for (int x = 0; x < abcCyr.length; x++) {
                if (message.charAt(i) == abcCyr[x]) {
                    builder.append(abcLat[x]);
                }
            }
        }
        return builder.toString();

    }

    private void closejMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closejMenuItemActionPerformed
        String[] options = new String[2];
        options[0] = "Да";
        options[1] = "Нет";
        int n = JOptionPane.showOptionDialog(null, "Хотите сохранить документ перед закрытием?", "Попытка закрыть документ", 0, JOptionPane.QUESTION_MESSAGE, null, options, null);
        if (n == 0) {
            if (fileToSave != null) {
                saveUsersXML();
            } else {
                JFileChooser fileChooser = new JFileChooser();
                fileChooser.setDialogTitle("Сохранить как");

                int userSelection = fileChooser.showSaveDialog(this);

                if (userSelection == JFileChooser.APPROVE_OPTION) {

                    fileToSave = fileChooser.getSelectedFile();

                    if (!getFileExtension(fileToSave).equals("xml")) {
                        fileToSave = new File(fileToSave.toString() + ".xml");
                    }

                    saveUsersXML();

                    saveMenuItem.setEnabled(true);

                }
            }
        }

        remove(jScrollPane);
        remove(jLabel1);
        remove(jLabel2);
        remove(jLabel3);
        remove(jLabel4);
        remove(jLabel5);
        remove(jLabel6);
        remove(jLabel7);

        remove(errorLabel);
        remove(errorNumberLabel);

        initComponents();

        errorLabel.setVisible(false);
        errorNumberLabel.setVisible(false);

        repaint();
        revalidate();

        numberOfTables = 0;
        tables = null;
        Jtables = null;
        selectedTable = -1;
        tableChecked = null;
        allErrors = 0;
        fileToSave = null;

        tableChecked = null;
        fileToSave = null;
    }//GEN-LAST:event_closejMenuItemActionPerformed

    private void jMenuItem6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem6ActionPerformed
        String[] options = new String[2];
        options[0] = "Да";
        options[1] = "Нет";
        int n = JOptionPane.showOptionDialog(null, "Вы действительно хотите прекратить выполнение программы?", "Попытка закрыть программу!", 0, JOptionPane.QUESTION_MESSAGE, null, options, null);
        if (n == 0) {
            System.exit(0);
        }
    }//GEN-LAST:event_jMenuItem6ActionPerformed

    private void jMenuItem8ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem8ActionPerformed
        Image image = Toolkit.getDefaultToolkit().createImage("images\\icons\\about-icon.png");
        ImageIcon icon = new ImageIcon(image);
        JOptionPane.showMessageDialog(this, "<html><h1>Данная программа позволит повысить вероятность <br>обнаружения ошибок документа перед конвертацией<br>в требуемый формат.</h1></html>", "О программе", JOptionPane.INFORMATION_MESSAGE, icon);
    }//GEN-LAST:event_jMenuItem8ActionPerformed

*
     * Hides frame


    private void hideWindow() {
        setVisible(false);
    }

*
     * Shows frame. Restores frame state (normal or maximized)


    private void restoreWindow() {
        setVisible(true);
        setExtendedState(getExtendedState() & (JFrame.ICONIFIED ^ 0xFFFF));
        requestFocus();
    }

*
     * Mouse listener for tray icon. Restores frame on double click.


    class TrayMouseListener extends MouseAdapter {

        @Override
        public void mouseClicked(MouseEvent e) {
            if (e.getClickCount() == 2) {
                restoreWindow();
            }
        }
    }

*
     * Window event listener. Hides frame in iconfying and window closing events


    class WindowMinimizeListener extends WindowAdapter {

        @Override
        public void windowClosing(WindowEvent e) {
            hideWindow();
        }

        @Override
        public void windowIconified(WindowEvent e) {
            hideWindow();
        }
    }

*
     * @param args the command line arguments


    public static void main(String args[]) {
        try {
 Set the Nimbus look and feel

            UIManager.setLookAndFeel("com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel");
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
            Logger.getLogger(MainJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        
        //</editor-fold>

 Create and display the form

        java.awt.EventQueue.invokeLater(() -> {
            MainJFrame mainFrame = new MainJFrame();
            mainFrame.setTitle("Визуализатор v_1.0");
            centerFrame(mainFrame);
            mainFrame.setResizable(false);
            mainFrame.setVisible(true);
        });
    }

*
     * Puts any Window or Frame to the centre of the screen.
     *
     * @param frame


    public static void centerFrame(JFrame frame) {
        frame.setLocationRelativeTo(null);
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem closejMenuItem;
    private javax.swing.JLabel errorLabel;
    private javax.swing.JLabel errorNumberLabel;
    private javax.swing.JMenu exportMenu;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenuAbout;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem4;
    private javax.swing.JMenuItem jMenuItem6;
    private javax.swing.JMenuItem jMenuItem7;
    private javax.swing.JMenuItem jMenuItem8;
    private javax.swing.JMenu jMenuTables;
    private static javax.swing.JPanel jPanel;
    private static javax.swing.JScrollPane jScrollPane;
    private javax.swing.JMenuItem saveAsMenuItem;
    private javax.swing.JMenuItem saveMenuItem;
    // End of variables declaration//GEN-END:variables

    private void showTablesItems(int tableNumber) {
        jMenuTables.remove(jMenuItem7);
        JMenuItem tableN = new JMenuItem();
        tableN.setIcon(new javax.swing.ImageIcon("images\\icons\\all_tables.png"));
        tableN.setText("Все таблицы");
        tableN.addActionListener(new AllTablesActionListener());
        jMenuTables.add(tableN);
        for (int i = 0; i < tableNumber; i++) {
            tableN = new JMenuItem();
            tableN.setIcon(new javax.swing.ImageIcon("images\\icons\\table.png"));
            tableN.setText("Таблица № " + (i + 1));
            tableN.addActionListener(new TableActionListener());
            jMenuTables.add(tableN);
        }
    }

    //метод определения расширения файла
    private static String getFileExtension(File file) {
        String fileName = file.getName();
        // если в имени файла есть точка и она не является первым символом в названии файла
        if (fileName.lastIndexOf(".") != -1 && fileName.lastIndexOf(".") != 0) // то вырезаем все знаки после последней точки в названии файла, то есть ХХХХХ.txt -> txt
        {
            return fileName.substring(fileName.lastIndexOf(".") + 1);
        } // в противном случае возвращаем заглушку, то есть расширение не найдено
        else {
            return "";
        }
    }

    private static int getNumberOfTables(File xml) {
        try {

            DocumentBuilderFactory dbFactory
                    = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            Document doc = dBuilder.parse(xml);
            doc.getDocumentElement().normalize();
            NodeList nList = doc.getElementsByTagName("tables-number");
            for (int i = 0; i < nList.getLength(); i++) {
                //numberOfTables = Integer.parseInt(nList.item(i).getTextContent());
                numberOfTables = 4;
            }

            NodeList nTable = doc.getElementsByTagName("table");
            boolean excessTable = false;

            for (int temp = 0; temp < nTable.getLength(); temp++) {
                excessTable = false;
                Node nNode = nTable.item(temp);

                if (nNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element eElement = (Element) nNode;
                    NamedNodeMap attributes = eElement.getAttributes();
                    int numAttrs = attributes.getLength();
                    for (int i = 0; i < numAttrs; i++) {
                        Attr attr = (Attr) attributes.item(i);
                        if (attr.getNodeName().equals("hidden") && attr.getNodeValue().equals("true")) {
                            excessTable = true;
                        }
                    }
                }
                if (excessTable) {
                    numberOfTables--;
                }
            }

        } catch (ParserConfigurationException | SAXException | IOException ex) {
            Logger.getLogger(MainJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }

        tableChecked = new boolean[numberOfTables];

        return numberOfTables;
    }

    private static void getContentOfAllTables(File xml) {
        try {

            tables = new ArrayList<>();

            Tables varTable = null;
            List<String> headColumns = null;
            List<String> columns = null;
            List< List<String>> lines = null;

            DocumentBuilderFactory dbFactory
                    = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            Document doc = dBuilder.parse(xml);
            doc.getDocumentElement().normalize();

            NodeList nList = doc.getElementsByTagName("table");
            boolean excessTable = false;

            int t = 0;

            Map<Integer, Integer> tableErrors = new HashMap<>();

            for (int temp = 0; temp < nList.getLength(); temp++) {

                excessTable = false;
                varTable = new Tables();

                Node nNode = nList.item(temp);

                if (nNode.getNodeType() == Node.ELEMENT_NODE) {

                    Element eElement = (Element) nNode;

                    NamedNodeMap attributes = eElement.getAttributes();
                    int numAttrs = attributes.getLength();
                    for (int i = 0; i < numAttrs; i++) {
                        Attr attr = (Attr) attributes.item(i);
                        if (attr.getNodeName().equals("hidden") && attr.getNodeValue().equals("true")) {
                            excessTable = true;
                        }
                    }
                    if (excessTable) {
                        continue;
                    } else {

                        varTable.setTableErrors(tableErrors, t);
                        t++;

                        varTable.setId(eElement.getAttribute("id").trim());
                        varTable.setTitle(eElement.getElementsByTagName("table-title")
                                .item(0)
                                .getTextContent().trim().replaceAll(",", "."));
                        varTable.setDescription(eElement.getElementsByTagName("table-description")
                                .item(0)
                                .getTextContent().trim());
                        Node head = eElement.getElementsByTagName("head-row").item(0);

                        headColumns = new ArrayList<>();

                        NodeList headList = head.getChildNodes();
                        for (int i = 0; i < headList.getLength(); i++) {
                            Node headNode = headList.item(i);
                            if (headNode.getNodeType() == Node.ELEMENT_NODE) {
                                Element secondeElement = (Element) headNode;
                                headColumns.add(secondeElement.getTextContent().trim().replaceAll(",", "."));
                            }
                        }

                        varTable.setHeadColumns(headColumns);

                        NodeList rows = eElement.getElementsByTagName("row");

                        lines = new ArrayList<>();

                        for (int j = 0; j < rows.getLength(); j++) {
                            Node rowNode = rows.item(j);
                            columns = new ArrayList<>();
                            NodeList cellsList = rowNode.getChildNodes();
                            for (int k = 0; k < cellsList.getLength(); k++) {
                                Node cellNode = cellsList.item(k);
                                if (cellNode.getNodeType() == Node.ELEMENT_NODE) {
                                    Element thirdeElement = (Element) cellNode;
                                    columns.add(thirdeElement.getTextContent().trim().replaceAll(",", "."));
                                }
                            }
                            lines.add(columns);
                        }
                        varTable.setRows(lines);
                    }
                }
                tables.add(varTable);
            }
        } catch (ParserConfigurationException | SAXException | IOException ex) {
            Logger.getLogger(MainJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void fillTable(boolean allTbls, int tableNumber) {

        Jtables = new ArrayList<>();
        JTable tbl = null;

        jPanel.setLayout(new GridBagLayout());
        GridBagConstraints c = new GridBagConstraints();
        c.gridy = 0;
        Tables table = null;

        if (allTbls == false) {
            table = tables.get(tableNumber);

            tableView(table, tbl, c, tableNumber);
        } else {

            for (int i = 0; i < numberOfTables; i++) {
                try {
                    table = tables.get(i);

                    if (tableChecked[i] == false) {
                        getContent(table, i);
                        tableChecked[i] = true;
                        allErrors += table.getTableErrors(table.getTableErrors(), i);
                    }
                } catch (Exception ex) {
                }
                tableView(table, tbl, c, tableNumber);
            }
        }

        jScrollPane.revalidate();
        jScrollPane.repaint();

    }

*
     * Utility method for setting the font and color of a JTextPane. The result
     * is roughly equivalent to calling setFont(...) and setForeground(...) on
     * an AWT TextArea.
     *
     * @param table
     * @param tbl
     * @param c


    public void tableView(Tables table, JTable tbl, GridBagConstraints c, int num) {

        Object columnNames[] = new String[table.getHeadColumns().size()];
        Object rowData[][] = new String[table.getRows().size()][table.getHeadColumns().size()];

        List<Integer> errorColumns = new ArrayList<>();

        for (int k = 0; k < table.getHeadColumns().size(); k++) {
            columnNames[k] = table.getHeadColumns().get(k);
            if (table.getHeadColumns().get(k).isEmpty()) {
                errorColumns.add(k);
            }
        }

        for (int m = 0; m < table.getRows().size(); m++) {
            for (int n = 0; n < table.getRows().get(m).size(); n++) {
                rowData[m][n] = table.getRows().get(m).get(n);
                if (rowData[m][n].toString().isEmpty() || rowData[m][n].toString().equals(" ")) {
                    rowData[m][n] = "НЕТ ДАННЫХ";
                }
            }
        }

        DefaultTableModel model = new DefaultTableModel(rowData, columnNames);
        tbl = new JTable(model);

        tbl.setShowGrid(true);

        tbl.setCellSelectionEnabled(true);

        tbl.setEnabled(false);

        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);

        Font cellFont = new Font("Verdana", Font.PLAIN, 14);

        for (int x = 0; x < tbl.getColumnCount(); x++) {
            tbl.getColumnModel().getColumn(x).setCellRenderer(centerRenderer);
            tbl.setRowHeight(30);
            tbl.setFont(cellFont);
        }

        tbl.setTableHeader(new JTableHeader(tbl.getColumnModel()) {
            @Override
            public Dimension getPreferredSize() {
                Dimension d = super.getPreferredSize();
                d.height = 45;
                return d;
            }
        });

        TableCellRenderer rend = tbl.getTableHeader().getDefaultRenderer();
        TableColumnModel tcm = tbl.getColumnModel();
        for (int j = 0; j < tcm.getColumnCount(); j += 1) {
            TableColumn tc = tcm.getColumn(j);
            TableCellRenderer rendCol = tc.getHeaderRenderer(); // likely null
            if (rendCol == null) {
                rendCol = rend;
            }
            Component component = rendCol.getTableCellRendererComponent(tbl, tc.getHeaderValue(), false, false, 0, j);
            tc.setPreferredWidth(component.getPreferredSize().width);
        }

        tbl.getTableHeader().addMouseListener(new ColumnHeaderListener());

        JTableHeader header = tbl.getTableHeader();
        header.setDefaultRenderer(new HeaderRenderer(tbl));

        Jtables.add(tbl);

        JLabel headerSpace01 = new JLabel("\t");
        jPanel.add(headerSpace01, c);

        c.ipadx = 40;
        c.gridy++;

        JTextPane tableTitle = new JTextPane();
        tableTitle.setEditable(false);

        SimpleAttributeSet attribs = new SimpleAttributeSet();
        StyleConstants.setAlignment(attribs, StyleConstants.ALIGN_CENTER);

        tableTitle.setParagraphAttributes(attribs, true);
        String title = table.getTitle();
        if (title.isEmpty() || title.contentEquals(" ") || title.contentEquals("  ")) {
            tableTitle.setBorder(BorderFactory.createLineBorder(Color.RED));
            tableTitle.setContentType("text/html");
            tableTitle.setText("<html><head></head><body><h1 style=\"text-align: center;\">" + "НЕТ ЗАГОЛОВКА!" + "</h1></body></html>");
            StyleConstants.setForeground(attribs, Color.BLUE);
            ((StyledDocument) tableTitle.getDocument()).setCharacterAttributes(0, tableTitle.getDocument().getLength(), attribs, false);
        } else {
            tableTitle.setText(table.getTitle());
        }

        Font BigFontTR = new Font("TimesRoman", Font.BOLD, 20);
        setJTextPaneFont(tableTitle, BigFontTR, Color.blue);

        tableTitle.addMouseListener(new MouseListener() {
            @Override
            public void mouseClicked(MouseEvent e) {
                editingTableTitle(tableTitle);
            }

            @Override
            public void mousePressed(MouseEvent e) {
                editingTableTitle(tableTitle);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
            }

            @Override
            public void mouseEntered(MouseEvent e) {
            }

            @Override
            public void mouseExited(MouseEvent e) {
            }

        });

        tbl.getTableHeader().setDefaultRenderer(new DefaultTableCellRenderer() {

            @Override
            public Component getTableCellRendererComponent(
                    JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                DefaultTableCellRenderer rendererComponent = (DefaultTableCellRenderer) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                rendererComponent.setHorizontalAlignment(JLabel.CENTER);
                rendererComponent.setFont(new Font("SansSerif", Font.BOLD, 20));

                if (errorColumns.contains(column)) {
                    rendererComponent.setBorder(BorderFactory.createLineBorder(Color.RED));
                    rendererComponent.setText("НЕТ ЗАГОЛОВКА");
                } else {
                    rendererComponent.setBorder(BorderFactory.createLineBorder(Color.BLACK));
                }

                return rendererComponent;
            }
        });

        for (int i = 0; i < tbl.getColumnCount(); i++) {
            tbl.getColumnModel().getColumn(i).setCellRenderer(new RenderRedBlack());
        }

        tbl.addMouseListener(new CellsMouseListener());

        jPanel.add(tableTitle, c);

        c.gridy++;
        JLabel headerSpace02 = new JLabel("\t");
        jPanel.add(headerSpace02, c);

        c.ipadx = 950;
        c.gridy++;
        jPanel.add(tbl.getTableHeader(), c);

        c.gridy++;
        jPanel.add(tbl, c);

        c.gridy++;
        JLabel headerSpace03 = new JLabel("\t");
        jPanel.add(headerSpace03, c);

        c.gridy++;
        JLabel headerSpace04 = new JLabel("\t");
        jPanel.add(headerSpace04, c);

        c.gridy++;

        if (num == -1) {
            Integer err = 0;

            errorLabel.setText("Вероятное количество ошибок документа:");
            errorLabel.setVisible(true);

            errorNumberLabel.setVisible(true);
            errorNumberLabel.setText(allErrors.toString());

        } else {
            errorLabel.setText("Вероятное количество ошибок таблицы:");
            errorLabel.setVisible(true);
            errorNumberLabel.setVisible(true);
            errorNumberLabel.setText(Integer.toString(table.getTableErrors(table.getTableErrors(), num)));
        }

    }

    public void getContent(Tables table, int num) {

        for (int k = 0; k < table.getHeadColumns().size(); k++) {
            if (table.getHeadColumns().get(k).isEmpty()) {
                if (num == -1) {
                    table.incrementTableErrors(table.getTableErrors(), 0);
                } else {
                    table.incrementTableErrors(table.getTableErrors(), num);
                }
            }
        }

        for (int m = 0; m < table.getRows().size(); m++) {
            for (int n = 0; n < table.getRows().get(m).size(); n++) {
                if (table.getRows().get(m).get(n).isEmpty() || table.getRows().get(m).get(n).equals(" ")) {
                    if (num == -1) {
                        table.incrementTableErrors(table.getTableErrors(), 0);
                    } else {
                        table.incrementTableErrors(table.getTableErrors(), num);
                    }
                }
            }
        }

        String title = table.getTitle();
        if (title.isEmpty() || title.contentEquals(" ") || title.contentEquals("  ")) {
            if (num == -1) {
                table.incrementTableErrors(table.getTableErrors(), 0);
            } else {
                table.incrementTableErrors(table.getTableErrors(), num);
            }
        }

    }

    public static void setJTextPaneFont(JTextPane jtp, Font font, Color c) {
        // Start with the current input attributes for the JTextPane. This
        // should ensure that we do not wipe out any existing attributes
        // (such as alignment or other paragraph attributes) currently
        // set on the text area.
        MutableAttributeSet attrs = jtp.getInputAttributes();

        // Set the font family, size, and style, based on properties of
        // the Font object. Note that JTextPane supports a number of
        // character attributes beyond those supported by the Font class.
        // For example, underline, strike-through, super- and sub-script.
        StyleConstants.setFontFamily(attrs, font.getFamily());
        StyleConstants.setFontSize(attrs, font.getSize());
        StyleConstants.setItalic(attrs, (font.getStyle() & Font.ITALIC) != 0);
        StyleConstants.setBold(attrs, (font.getStyle() & Font.BOLD) != 0);

        // Set the font color
        StyleConstants.setForeground(attrs, c);

        // Retrieve the pane's document object
        StyledDocument doc = jtp.getStyledDocument();

        // Replace the style for the entire document. We exceed the length
        // of the document by 1 so that text entered at the end of the
        // document uses the attributes.
        doc.setCharacterAttributes(0, doc.getLength() + 1, attrs, false);
    }

    private void editingTableTitle(JTextPane tableTitle) {
        String[] options = new String[2];
        options[0] = "Да";
        options[1] = "Нет";
        int n = JOptionPane.showOptionDialog(null, "Вы действительно хотите редактировать заголовок таблицы?", "Внимание!", 0, JOptionPane.YES_NO_OPTION, null, options, null);
        if (n == 0) {
            Tables tempTable = tables.get(selectedTable);
            TitleEditorFrame headerEditor = new TitleEditorFrame(tableTitle, tempTable);
            String name = tableTitle.getText();
            headerEditor.setOldHeader(name);
            headerEditor.setVisible(true);
        } else {
            tableTitle.setEditable(false);
        }
    }

    private static class HeaderRenderer implements TableCellRenderer {

        DefaultTableCellRenderer renderer;

        public HeaderRenderer(JTable table) {
            renderer = (DefaultTableCellRenderer) table.getTableHeader().getDefaultRenderer();
            renderer.setHorizontalAlignment(JLabel.CENTER);
        }

        @Override
        public Component getTableCellRendererComponent(
                JTable table, Object value, boolean isSelected,
                boolean hasFocus, int row, int col) {
            return renderer.getTableCellRendererComponent(
                    table, value, isSelected, hasFocus, row, col);
        }
    }

    class ColumnHeaderListener extends MouseAdapter {

        @Override
        public void mouseClicked(MouseEvent evt) {
            JTable table = ((JTableHeader) evt.getSource()).getTable();
            TableColumnModel colModel = table.getColumnModel();

            int index = colModel.getColumnIndexAtX(evt.getX());
            if (index == -1) {
                return;
            } else {
                String val = (String) colModel.getColumn(index).getHeaderValue();
                String[] options = new String[2];
                options[0] = "Да";
                options[1] = "Нет";
                int n = JOptionPane.showOptionDialog(null, "Вы действительно хотите редактировать название столбца?", "Внимание!", 0, JOptionPane.YES_NO_OPTION, null, options, null);
                if (n == 0) {
                    Tables tempTable = tables.get(selectedTable);
                    HeaderEditorFrame headerEditorFrame = new HeaderEditorFrame(tempTable, val, colModel, index, jScrollPane);
                    headerEditorFrame.setVisible(true);
                }
            }
        }
    }

    class CellsMouseListener extends MouseAdapter {

        @Override
        public void mouseClicked(MouseEvent e) {
            JTable theTable = (JTable) e.getSource();
            int row = theTable.rowAtPoint(e.getPoint());//get mouse-selected row
            int col = theTable.columnAtPoint(e.getPoint());//get mouse-selected col
            String val = (String) theTable.getValueAt(row, col);
            String[] options = new String[2];
            options[0] = "Да";
            options[1] = "Нет";
            int n = JOptionPane.showOptionDialog(null, "Вы действительно хотите редактировать значение данной ячейки?", "Внимание!", 0, JOptionPane.YES_NO_OPTION, null, options, null);
            if (n == 0) {
                Tables tempTable = tables.get(selectedTable);
                theTable.setCellSelectionEnabled(true);
                theTable.changeSelection(row, col, false, false);
                theTable.requestFocus();
                CellEditorFrame cellEditorFrame = new CellEditorFrame(theTable, row, col, val, tempTable);
                cellEditorFrame.setVisible(true);
            }
        }
    }

    final class RenderRedBlack extends DefaultTableCellRenderer {

        RenderRedBlack() {
            setHorizontalAlignment(SwingConstants.CENTER);
        }

        @Override
        public Component getTableCellRendererComponent(
                JTable aTable, Object aNumberValue, boolean aIsSelected,
                boolean aHasFocus, int aRow, int aColumn
        ) {
    * Implementation Note :
    * It is important that no 'new' objects be present in this 
    * implementation (excluding exceptions):
    * if the table is large, then a large number of objects would be 
    * created during rendering.


            if (aNumberValue == null) {
                return this;
            }
            Component renderer = super.getTableCellRendererComponent(
                    aTable, aNumberValue, aIsSelected, aHasFocus, aRow, aColumn
            );
            Object value = aNumberValue;
            if (value.equals("НЕТ ДАННЫХ")) {
                renderer.setForeground(Color.red);
            } else {
                renderer.setForeground(fDarkGreen);
            }
            return this;
        }

        // PRIVATE 
        //the default green is too bright and illegible
        private Color fDarkGreen = Color.green.darker();
    }

}
*/
